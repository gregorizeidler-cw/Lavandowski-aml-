import datetime
import pandas as pd
from google.cloud import bigquery
from gpt_utils import get_chatgpt_response
import json
import decimal
import logging
import os
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(level=logging.ERROR)

# Create a custom JSON encoder to handle Decimal objects
class CustomJSONEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, decimal.Decimal):
            return float(obj)
        elif isinstance(obj, (pd.Timestamp, datetime.datetime, datetime.date)):
            return obj.isoformat()
        else:
            return super().default(obj)

# Set up Pandas options
pd.set_option('display.max_columns', None)
pd.set_option('display.max_rows', 40)
pd.set_option('display.min_rows', 40)

# Connect to Google Cloud project
project_id = os.getenv("GOOGLE_CLOUD_PROJECT")
location = os.getenv("LOCATION")
client = bigquery.Client(project=project_id, location=location)

def format_date_portuguese(date_str: str) -> str:
    """Formats a date string to Portuguese date format."""
    if date_str is None:
        return 'Not available.'
    month_names = {
        1: "Janeiro", 2: "Fevereiro", 3: "MarÃ§o", 4: "Abril", 5: "Maio", 6: "Junho",
        7: "Julho", 8: "Agosto", 9: "Setembro", 10: "Outubro", 11: "Novembro", 12: "Dezembro"
    }
    date = datetime.datetime.strptime(date_str, '%d-%m-%Y')
    return f"{date.day} de {month_names[date.month]} de {date.year}"

def format_cpf(cpf: str) -> str:
    """Formats a CPF string."""
    if cpf is None:
        return None
    cpf = cpf.replace('.', '').replace('-', '')
    if len(cpf) == 11:
        formatted_cpf = f"{cpf[:3]}.{cpf[3:6]}.{cpf[6:9]}-{cpf[9:11]}"
        return formatted_cpf
    else:
        return cpf

def execute_query(query):
    """Executes a BigQuery SQL query and returns a DataFrame."""
    try:
        df = client.query(query).result().to_dataframe()
        return df
    except Exception as e:
        logging.error(f"Error executing query: {e}")
        return pd.DataFrame()

def fetch_lawsuit_data(user_id: int) -> pd.DataFrame:
    """Fetches lawsuit data for the given user_id (New Lighter Logic)."""
    query = f"""
    SELECT * FROM `infinitepay-production.metrics_amlft.lavandowski_lawsuits_data` WHERE user_id = {user_id}
    """
    df = execute_query(query)
    return df

def fetch_business_data(user_id: int) -> pd.DataFrame:
    """Fetches business data for the given user_id."""
    query = f"""
    SELECT * FROM `infinitepay-production.metrics_amlft.lavandowski_business_relationships_data` WHERE user_id = {user_id}
    """
    df = execute_query(query)
    return df

def fetch_sanctions_history(user_id: int) -> pd.DataFrame:
    """Fetches KYC sanctions history for the given user_id."""
    query = f"""
    SELECT * FROM infinitepay-production.metrics_amlft.sanctions_history WHERE user_id = {user_id}
    """
    df = execute_query(query)
    return df

def fetch_denied_transactions(user_id: int) -> pd.DataFrame:
    """Fetches denied transactions for the given user_id (merchant_id)."""
    query = f"""
    SELECT * FROM `infinitepay-production.metrics_amlft.lavandowski_risk_transactions_data` WHERE merchant_id = {user_id} ORDER BY card_number
    """
    df = execute_query(query)
    return df

def fetch_denied_pix_transactions(user_id: int) -> pd.DataFrame:
    """Fetches denied PIX transactions for the given user_id and the risk check that failed."""
    query = f"""
    SELECT * FROM `infinitepay-production.metrics_amlft.lavandowski_risk_pix_transfers_data` WHERE debitor_user_id = '{user_id}' ORDER BY str_pix_transfer_id DESC
    """
    df = execute_query(query)
    return df

def convert_decimals(data):
    """Recursively converts decimal.Decimal objects to float in data."""
    if isinstance(data, list):
        return [
            {
                k: float(v) if isinstance(v, (decimal.Decimal, float, int)) else v
                for k, v in item.items()
            }
            for item in data
        ]
    elif isinstance(data, dict):
        return {
            k: float(v) if isinstance(v, (decimal.Decimal, float, int)) else v
            for k, v in data.items()
        }
    else:
        return data

def fetch_prison_transactions(user_id: int) -> pd.DataFrame:
    """Fetches prison transactions for the given user_id."""
    query = f"""
    SELECT * EXCEPT(user_id) FROM infinitepay-production.metrics_amlft.prison_transactions WHERE user_id = {user_id}
    """
    df = execute_query(query)
    return df

def merchant_report(user_id: int, alert_type: str, pep_data=None) -> dict:
    """Generates a report for a merchant user."""
    # Define queries
    query_merchants = f"""
    SELECT * FROM metrics_amlft.merchant_report WHERE user_id = {user_id} LIMIT 1
    """

    # UPDATED ISSUING QUERY
    query_issuing_concentration = f"""
    SELECT * FROM `infinitepay-production.metrics_amlft.lavandowski_issuing_payments_data` WHERE user_id = {user_id}
    """

    query_pix_concentration = f"""
    SELECT * FROM metrics_amlft.pix_concentration WHERE user_id = {user_id}
    """

    query_offense_history = f"""
    SELECT * FROM `infinitepay-production.metrics_amlft.lavandowski_offense_analysis_data` WHERE user_id =  {user_id} ORDER BY id DESC
    """

    query_transaction_concentration = f"""
    SELECT * EXCEPT(merchant_id) FROM metrics_amlft.cardholder_concentration WHERE merchant_id = {user_id} ORDER BY total_approved_by_ch DESC
    """

    products_online_store = f"""
    SELECT * FROM `infinitepay-production.metrics_amlft.lavandowski_online_store_data` WHERE user_id = {user_id}
    """

    contacts_query = f"""
    SELECT * FROM `infinitepay-production.metrics_amlft.lavandowski_phonecast_data` WHERE user_id = {user_id}
    """

    devices_query = f"""
    SELECT * EXCEPT(user_id) FROM metrics_amlft.user_device WHERE user_id = {user_id}
    """

    # Initialize variables
    merchant_info = pd.DataFrame()
    issuing_concentration = pd.DataFrame()
    pix_concentration = pd.DataFrame()
    offense_history = pd.DataFrame()
    transaction_concentration = pd.DataFrame()
    products_online = pd.DataFrame()
    contacts = pd.DataFrame()
    devices = pd.DataFrame()
    cash_in = pd.DataFrame()
    cash_out = pd.DataFrame()
    total_cash_in_pix = 0.0
    total_cash_out_pix = 0.0
    total_cash_in_pix_atypical_hours = 0.0
    total_cash_out_pix_atypical_hours = 0.0

    # Execute queries
    merchant_info = execute_query(query_merchants)
    issuing_concentration = execute_query(query_issuing_concentration)
    pix_concentration = execute_query(query_pix_concentration)
    offense_history = execute_query(query_offense_history)
    transaction_concentration = execute_query(query_transaction_concentration)
    products_online = execute_query(products_online_store)
    contacts = execute_query(contacts_query)
    devices = execute_query(devices_query)

    # Process PIX concentrations
    if not pix_concentration.empty:
        cash_in = pix_concentration[pix_concentration['transaction_type'] == 'Cash In'].round(2)
        cash_out = pix_concentration[pix_concentration['transaction_type'] == 'Cash Out'].round(2)
        total_cash_in_pix = cash_in['pix_amount'].sum()
        total_cash_out_pix = cash_out['pix_amount'].sum()
        total_cash_in_pix_atypical_hours = cash_in['pix_amount_atypical_hours'].sum()
        total_cash_out_pix_atypical_hours = cash_out['pix_amount_atypical_hours'].sum()

    # Convert DataFrames to dictionaries
    merchant_info_dict = merchant_info.to_dict(orient='records')[0] if not merchant_info.empty else {}
    issuing_concentration_list = issuing_concentration.to_dict(orient='records') if not issuing_concentration.empty else []
    cash_in_list = cash_in.to_dict(orient='records') if not cash_in.empty else []
    cash_out_list = cash_out.to_dict(orient='records') if not cash_out.empty else []
    offense_history_list = offense_history.to_dict(orient='records') if not offense_history.empty else []
    transaction_concentration_list = transaction_concentration.to_dict(orient='records') if not transaction_concentration.empty else []
    products_online_list = products_online.to_dict(orient='records') if not products_online.empty else []
    contacts_list = contacts.to_dict(orient='records') if not contacts.empty else []
    devices_list = devices.to_dict(orient='records') if not devices.empty else []

    # Convert decimals
    merchant_info_dict = convert_decimals(merchant_info_dict)
    issuing_concentration_list = convert_decimals(issuing_concentration_list)
    cash_in_list = convert_decimals(cash_in_list)
    cash_out_list = convert_decimals(cash_out_list)
    offense_history_list = convert_decimals(offense_history_list)
    transaction_concentration_list = convert_decimals(transaction_concentration_list)
    products_online_list = convert_decimals(products_online_list)
    contacts_list = convert_decimals(contacts_list)
    devices_list = convert_decimals(devices_list)

    # Fetch lawsuit data
    lawsuit_data = fetch_lawsuit_data(user_id)
    lawsuit_data = lawsuit_data.to_dict(orient='records') if not lawsuit_data.empty else []

    # Fetch denied transactions
    denied_transactions_df = fetch_denied_transactions(user_id)
    denied_transactions_list = denied_transactions_df.to_dict(orient='records') if not denied_transactions_df.empty else []

    # Fetch business data
    business_data = fetch_business_data(user_id)
    business_data_list = business_data.to_dict(orient='records') if not business_data.empty else []

    # Fetch prison transactions
    prison_transactions_df = fetch_prison_transactions(user_id)
    prison_transactions_list = prison_transactions_df.to_dict(orient='records') if not prison_transactions_df.empty else []

    # Convert decimals
    prison_transactions_list = convert_decimals(prison_transactions_list)

    # Fetch KYC sanctions history data
    sanctions_history_df = fetch_sanctions_history(user_id)
    sanctions_history_list = sanctions_history_df.to_dict(orient='records') if not sanctions_history_df.empty else []

    # Convert decimals if necessary (assuming sanctions history data might contain decimals)
    sanctions_history_list = convert_decimals(sanctions_history_list)

    # Fetch denied PIX transactions
    denied_pix_transactions_df = fetch_denied_pix_transactions(user_id)
    denied_pix_transactions_list = denied_pix_transactions_df.to_dict(orient='records') if not denied_pix_transactions_df.empty else []

    # Convert decimals if necessary
    denied_pix_transactions_list = convert_decimals(denied_pix_transactions_list)

    # Create report dictionary
    report = {
        "merchant_info": merchant_info_dict,
        "total_cash_in_pix": total_cash_in_pix,
        "total_cash_out_pix": total_cash_out_pix,
        "total_cash_in_pix_atypical_hours": total_cash_in_pix_atypical_hours,
        "total_cash_out_pix_atypical_hours": total_cash_out_pix_atypical_hours,
        "issuing_concentration": issuing_concentration_list,
        "pix_cash_in": cash_in_list,
        "pix_cash_out": cash_out_list,
        "offense_history": offense_history_list,
        "transaction_concentration": transaction_concentration_list,
        "products_online": products_online_list,
        "contacts": contacts_list,
        "devices": devices_list,
        "lawsuit_data": lawsuit_data,
        "denied_transactions": denied_transactions_list,
        "business_data": business_data_list,
        "prison_transactions": prison_transactions_list,
        "sanctions_history": sanctions_history_list,
        "denied_pix_transactions": denied_pix_transactions_list
    }

    return report

def cardholder_report(user_id: int, alert_type: str, pep_data=None) -> dict:
    """Generates a report for a cardholder user."""
    # Define queries
    query_cardholders = f"""
    SELECT * FROM metrics_amlft.cardholder_report WHERE user_id = {user_id} LIMIT 1
    """

    query_issuing_concentration = f"""
    SELECT * EXCEPT(user_id) FROM metrics_amlft.issuing_concentration WHERE user_id = {user_id}
    """

    query_pix_concentration = f"""
    SELECT * FROM metrics_amlft.pix_concentration WHERE user_id = {user_id}
    """

    query_offense_history = f"""
    SELECT * FROM `infinitepay-production.metrics_amlft.lavandowski_offense_analysis_data` WHERE user_id =  {user_id} ORDER BY id DESC
    """

    contacts_query = f"""
    SELECT * FROM `infinitepay-production.metrics_amlft.lavandowski_phonecast_data` WHERE user_id = {user_id}
    """

    devices_query = f"""
    SELECT * EXCEPT(user_id) FROM metrics_amlft.user_device WHERE user_id = {user_id}
    """

    # Initialize variables
    cardholder_info = pd.DataFrame()
    issuing_concentration = pd.DataFrame()
    pix_concentration = pd.DataFrame()
    offense_history = pd.DataFrame()
    contacts = pd.DataFrame()
    devices = pd.DataFrame()
    cash_in = pd.DataFrame()
    cash_out = pd.DataFrame()
    total_cash_in_pix = 0.0
    total_cash_out_pix = 0.0
    total_cash_in_pix_atypical_hours = 0.0
    total_cash_out_pix_atypical_hours = 0.0

    # Execute queries
    cardholder_info = execute_query(query_cardholders)
    issuing_concentration = execute_query(query_issuing_concentration)
    pix_concentration = execute_query(query_pix_concentration)
    offense_history = execute_query(query_offense_history)
    contacts = execute_query(contacts_query)
    devices = execute_query(devices_query)

    # Process PIX concentrations
    if not pix_concentration.empty:
        cash_in = pix_concentration[pix_concentration['transaction_type'] == 'Cash In'].round(2)
        cash_out = pix_concentration[pix_concentration['transaction_type'] == 'Cash Out'].round(2)
        total_cash_in_pix = cash_in['pix_amount'].sum()
        total_cash_out_pix = cash_out['pix_amount'].sum()
        total_cash_in_pix_atypical_hours = cash_in['pix_amount_atypical_hours'].sum()
        total_cash_out_pix_atypical_hours = cash_out['pix_amount_atypical_hours'].sum()

    # Convert DataFrames to dictionaries
    cardholder_info_dict = cardholder_info.to_dict(orient='records')[0] if not cardholder_info.empty else {}
    issuing_concentration_list = issuing_concentration.to_dict(orient='records') if not issuing_concentration.empty else []
    cash_in_list = cash_in.to_dict(orient='records') if not cash_in.empty else []
    cash_out_list = cash_out.to_dict(orient='records') if not cash_out.empty else []
    offense_history_list = offense_history.to_dict(orient='records') if not offense_history.empty else []
    contacts_list = contacts.to_dict(orient='records') if not contacts.empty else []
    devices_list = devices.to_dict(orient='records') if not devices.empty else []

    # Convert decimals
    cardholder_info_dict = convert_decimals(cardholder_info_dict)
    issuing_concentration_list = convert_decimals(issuing_concentration_list)
    cash_in_list = convert_decimals(cash_in_list)
    cash_out_list = convert_decimals(cash_out_list)
    offense_history_list = convert_decimals(offense_history_list)
    contacts_list = convert_decimals(contacts_list)
    devices_list = convert_decimals(devices_list)

    # Fetch lawsuit data
    lawsuit_data = fetch_lawsuit_data(user_id)
    lawsuit_data = lawsuit_data.to_dict(orient='records') if not lawsuit_data.empty else []

    # Fetch business data
    business_data = fetch_business_data(user_id)
    business_data_list = business_data.to_dict(orient='records') if not business_data.empty else []

    # Fetch prison transactions
    prison_transactions_df = fetch_prison_transactions(user_id)
    prison_transactions_list = prison_transactions_df.to_dict(orient='records') if not prison_transactions_df.empty else []

    # Convert decimals
    prison_transactions_list = convert_decimals(prison_transactions_list)

    # Fetch KYC sanctions history data
    sanctions_history_df = fetch_sanctions_history(user_id)
    sanctions_history_list = sanctions_history_df.to_dict(orient='records') if not sanctions_history_df.empty else []

    # Convert decimals if necessary
    sanctions_history_list = convert_decimals(sanctions_history_list)

    # Fetch denied PIX transactions
    denied_pix_transactions_df = fetch_denied_pix_transactions(user_id)
    denied_pix_transactions_list = denied_pix_transactions_df.to_dict(orient='records') if not denied_pix_transactions_df.empty else []

    # Convert decimals if necessary
    denied_pix_transactions_list = convert_decimals(denied_pix_transactions_list)

    # Create report dictionary
    report = {
        "cardholder_info": cardholder_info_dict,
        "total_cash_in_pix": total_cash_in_pix,
        "total_cash_out_pix": total_cash_out_pix,
        "total_cash_in_pix_atypical_hours": total_cash_in_pix_atypical_hours,
        "total_cash_out_pix_atypical_hours": total_cash_out_pix_atypical_hours,
        "issuing_concentration": issuing_concentration_list,
        "pix_cash_in": cash_in_list,
        "pix_cash_out": cash_out_list,
        "offense_history": offense_history_list,
        "contacts": contacts_list,
        "devices": devices_list,
        "lawsuit_data": lawsuit_data,
        "business_data": business_data_list,
        "prison_transactions": prison_transactions_list,
        "sanctions_history": sanctions_history_list,
        "denied_pix_transactions": denied_pix_transactions_list
    }

    return report

def generate_prompt(report_data: dict, user_type: str, alert_type: str, betting_houses: pd.DataFrame = None, pep_data: pd.DataFrame = None, features: str = None) -> str:
    """Generates the prompt for the GPT model based on the report data."""
    import json

    # Serialize data to JSON strings
    user_info_key = f"{user_type.lower()}_info"
    user_info_json = json.dumps(report_data[user_info_key], ensure_ascii=False, indent=2, cls=CustomJSONEncoder)

    issuing_concentration_json = json.dumps(report_data.get('issuing_concentration', []), ensure_ascii=False, indent=2, cls=CustomJSONEncoder)
    pix_cash_in_json = json.dumps(report_data.get('pix_cash_in', []), ensure_ascii=False, indent=2, cls=CustomJSONEncoder)
    pix_cash_out_json = json.dumps(report_data.get('pix_cash_out', []), ensure_ascii=False, indent=2, cls=CustomJSONEncoder)
    offense_history_json = json.dumps(report_data.get('offense_history', []), ensure_ascii=False, indent=2, cls=CustomJSONEncoder)
    contacts_json = json.dumps(report_data.get('contacts', []), ensure_ascii=False, indent=2, cls=CustomJSONEncoder)
    devices_json = json.dumps(report_data.get('devices', []), ensure_ascii=False, indent=2, cls=CustomJSONEncoder)
    lawsuit_data_json = json.dumps(report_data.get('lawsuit_data', []), ensure_ascii=False, indent=2, cls=CustomJSONEncoder)
    denied_transactions_json = json.dumps(report_data.get('denied_transactions', []), ensure_ascii=False, indent=2, cls=CustomJSONEncoder)
    business_data_json = json.dumps(report_data.get('business_data', []), ensure_ascii=False, indent=2, cls=CustomJSONEncoder)
    prison_transactions_json = json.dumps(report_data.get('prison_transactions', []), ensure_ascii=False, indent=2, cls=CustomJSONEncoder)
    sanctions_history_json = json.dumps(report_data.get('sanctions_history', []), ensure_ascii=False, indent=2, cls=CustomJSONEncoder)
    denied_pix_transactions_json = json.dumps(report_data.get('denied_pix_transactions', []), ensure_ascii=False, indent=2, cls=CustomJSONEncoder)
    transaction_concentration_json = json.dumps(report_data.get('transaction_concentration', []), ensure_ascii=False, indent=2, cls=CustomJSONEncoder)

    prompt = f"""
Por favor, analise o caso abaixo.

Considere os seguintes nÃ­veis de risco:
1 - Baixo;
2 - MÃ©dio (possÃ­vel ligaÃ§Ã£o com PEPs);
3 - Alto (PEP, indivÃ­duos ou empresas com histÃ³rico em listas de sanÃ§Ãµes, etc.)

Tipo de Alerta: {alert_type}

InformaÃ§Ã£o do {user_type}:
{user_info_json}
"""

    # Include data specific to merchants
    if user_type == 'Merchant':
        products_online_json = json.dumps(report_data.get('products_online', []), ensure_ascii=False, indent=2, cls=CustomJSONEncoder)
        prompt += f"""
Total de TransaÃ§Ãµes PIX:
- Cash In: R${report_data['total_cash_in_pix']:,.2f}
- Cash Out: R${report_data['total_cash_out_pix']:,.2f}

TransaÃ§Ãµes em HorÃ¡rios AtÃ­picos:
- Cash In PIX: R${report_data['total_cash_in_pix_atypical_hours']:,.2f}
- Cash Out PIX: R${report_data['total_cash_out_pix_atypical_hours']:,.2f}

ConcentraÃ§Ã£o de TransaÃ§Ãµes por Portador de CartÃ£o:
{transaction_concentration_json}

AnÃ¡lise Adicional para ConcentraÃ§Ã£o de TransaÃ§Ãµes por Portador de CartÃ£o:
- Verifique se hÃ¡ transaÃ§Ãµes com valores idÃªnticos ou muito similares (usando card_holder_name, card_number e card_token_id) ocorrendo em intervalos curtos.
- Utilize os campos total_approved_by_ch e count_approved_transactions para identificar portadores com volume elevado e detectar picos anormais.
- Analise os valores de total_approved_by_ch_atypical_hours e Percentage_atypica para identificar transaÃ§Ãµes em horÃ¡rios atÃ­picos com padrÃµes suspeitos.
- Avalie o capture_method para verificar se determinados mÃ©todos de captura estÃ£o concentrados.
- Verifique a concentraÃ§Ã£o por emissor (issuer_id e issuer_name) e considere o risco associado ao country do emissor.

ConcentraÃ§Ã£o de Issuing:
{issuing_concentration_json}

AnÃ¡lise Adicional para ConcentraÃ§Ã£o de Issuing:
- Verifique se hÃ¡ repetiÃ§Ã£o de merchant_name ou padrÃµes de valores anÃ´malos em total_amount.
- Utilize os campos total_amount, percentage_of_total, message__card_acceptor_mcc e message__card_acceptor_country_code para identificar picos ou concentraÃ§Ãµes excessivas.
- Compare os valores de total_amount com o percentage_of_total para detectar discrepÃ¢ncias ou padrÃµes incomuns.
- Caso existam transaÃ§Ãµes repetidas ou com valores atÃ­picos, destaque essas ocorrÃªncias e discuta possÃ­veis riscos associados.
- Avalie se os cÃ³digos MCC (message__card_acceptor_mcc) correspondem a setores de alto risco e se o paÃ­s do adquirente (message__card_acceptor_country_code) aponta para origens que requeiram atenÃ§Ã£o especial.

TransaÃ§Ãµes Negadas:
{denied_transactions_json}

HistÃ³rico Profissional:
{business_data_json}

TransaÃ§Ãµes Confirmadamente Executadas Dentro do PresÃ­dio (AtenÃ§Ã£o especial Ã s colunas status e transaction_type. TransaÃ§Ãµes negadas ou com errors tambÃ©m devem ser consideradas):
{prison_transactions_json}

Contatos:
{contacts_json}

Dispositivos Utilizados:
{devices_json}

Produtos na Loja InfinitePay:
{products_online_json}

SanÃ§Ãµes Judiciais (DÃª detalhes sobre o caso durante a anÃ¡lise. PensÃ£o alimentÃ­cia ou casos de famÃ­lia podem ser desconsiderados):
{sanctions_history_json}

TransaÃ§Ã£o PIX Negadas e motivo (coluna risk_check):
{denied_pix_transactions_json}

ConcentraÃ§Ãµes PIX:
Cash In:
{pix_cash_in_json}
Cash Out:
{pix_cash_out_json}

InformaÃ§Ãµes sobre processos judiciais:
{lawsuit_data_json}

HistÃ³rico de Offenses:
{offense_history_json}
"""
    else:  # For cardholders
        prompt += f"""
Total de TransaÃ§Ãµes PIX:
- Cash In: R${report_data['total_cash_in_pix']:,.2f}
- Cash Out: R${report_data['total_cash_out_pix']:,.2f}

TransaÃ§Ãµes em HorÃ¡rios AtÃ­picos:
- Cash In PIX: R${report_data['total_cash_in_pix_atypical_hours']:,.2f}
- Cash Out PIX: R${report_data['total_cash_out_pix_atypical_hours']:,.2f}

ConcentraÃ§Ã£o de Issuing:
{issuing_concentration_json}

AnÃ¡lise Adicional para ConcentraÃ§Ã£o de Issuing:
- Verifique se hÃ¡ padrÃµes de valores anÃ´malos em total_amount e se o percentage_of_total indica concentraÃ§Ã£o elevada.
- Identifique possÃ­veis discrepÃ¢ncias ou repetiÃ§Ãµes em merchant_name e total_amount.
- Discuta qualquer padrÃ£o incomum que possa sugerir risco ou concentraÃ§Ã£o excessiva.

Contatos (AtenÃ§Ã£o para contatos com status 'blocked'):
{contacts_json}

Dispositivos Utilizados (atenÃ§Ã£o para nÃºmero elevado de dispositivos):
{devices_json}

SanÃ§Ãµes Judiciais (DÃª detalhes sobre o caso durante a anÃ¡lise. PensÃ£o alimentÃ­cia ou casos de famÃ­lia podem ser desconsiderados):
{sanctions_history_json}

TransaÃ§Ã£o PIX Negadas e motivo (coluna risk_check):
{denied_pix_transactions_json}

ConcentraÃ§Ãµes PIX:
Cash In:
{pix_cash_in_json}
Cash Out:
{pix_cash_out_json}

HistÃ³rico Profissional:
{business_data_json}

InformaÃ§Ãµes sobre processos judiciais:
{prison_transactions_json}

HistÃ³rico de Offenses:
{offense_history_json}

TransaÃ§Ãµes de Apostas via PIX:
{bets_pix_transfers_json}

"""

    # Additional instructions based on alert type
    if alert_type == 'betting_houses_alert [BR]' and betting_houses is not None:
        betting_houses_json = betting_houses.to_json(orient='records', force_ascii=False, indent=2)
        prompt += f"""
A primeira frase da sua anÃ¡lise deve ser: "Cliente estÃ¡ transacionando com casas de apostas."

AtenÃ§Ã£o especial para transaÃ§Ãµes com as casas de apostas abaixo:
{betting_houses_json}

Para CADA transaÃ§Ã£o em Cash In e Cash Out, vocÃª DEVE:
1. Verificar se o nome da parte ou o CNPJ corresponde a alguma das casas de apostas listadas acima.
2. Se houver correspondÃªncia, calcular:
   a) A soma total de valores transacionados com essa casa de apostas especÃ­fica.
   b) A porcentagem que essa soma representa do valor TOTAL de Cash In ou Cash Out (conforme aplicÃ¡vel).

Na sua anÃ¡lise, descreva:
- A soma total de Cash In e Cash Out para cada casa de apostas correspondente.
- A porcentagem que esses valores representam do total de Cash In e Cash Out.
- Discuta quaisquer padrÃµes ou anomalias observados nessas transaÃ§Ãµes.

Lembre-se: Esta verificaÃ§Ã£o deve ser feita para TODAS as transaÃ§Ãµes, independentemente do tipo de alerta.
"""
    elif alert_type == 'goverment_corporate_cards_alert [BR]':
        prompt += f"""
A primeira frase da sua anÃ¡lise deve ser: "Cliente estÃ¡ transacionando com cartÃµes corporativos governamentais."

AtenÃ§Ã£o especial para transaÃ§Ãµes com BINs de cartÃµes de crÃ©dito que comeÃ§am com os seguintes prefixos:
- 409869
- 467481
- 498409

Para CADA transaÃ§Ã£o, vocÃª DEVE:
1. Verificar se o BIN (os primeiros 6 dÃ­gitos do nÃºmero do cartÃ£o) corresponde a algum dos prefixos listados acima.
2. Se houver correspondÃªncia, calcular:
   a) A soma total de valores transacionados com esses BINs especÃ­ficos.
   b) A porcentagem que essa soma representa do valor de TPV TOTAL (conforme aplicÃ¡vel).

Na sua anÃ¡lise, descreva:
- A soma total de valores para cada prefixo BIN correspondente.
- A porcentagem que esses valores representam do total de Cash In e Cash Out.
- Discuta quaisquer padrÃµes ou anomalias observados nessas transaÃ§Ãµes.

Lembre-se: Esta verificaÃ§Ã£o deve ser feita para TODAS as transaÃ§Ãµes de cartÃµes de crÃ©dito relacionadas a este alerta.
Se nÃ£o houver correspondÃªncias com os BINs listados, informe explicitamente na sua anÃ¡lise.
"""
    elif alert_type == 'ch_alert [BR]':
        prompt += f"""
A primeira frase da sua anÃ¡lise deve ser: "Cliente com possÃ­veis anomalias em PIX."

AtenÃ§Ã£o especial para TransaÃ§Ãµes PIX:

Para CADA transaÃ§Ã£o em Cash In e Cash Out, vocÃª DEVE:
1. Analisar os valores de Cash In e Cash Out para identificar quaisquer anomalias ou padrÃµes suspeitos.
2. Comparar os valores com transaÃ§Ãµes tÃ­picas para determinar se hÃ¡ desvios significativos.

Na sua anÃ¡lise, descreva:
- Quaisquer transaÃ§Ãµes de Cash In ou Cash Out que apresentam valores anormais.
- PadrÃµes ou tendÃªncias observadas nas transaÃ§Ãµes PIX.
- RecomendaÃ§Ã£o sobre a necessidade de investigaÃ§Ã£o adicional com base nos achados.

Lembre-se: Esta verificaÃ§Ã£o deve ser feita para TODAS as transaÃ§Ãµes PIX relacionadas a este alerta.
Se nÃ£o houver anomalias detectadas, informe explicitamente na sua anÃ¡lise.

AlÃ©m disso, vocÃª deve verificar se o usuÃ¡rio pode ser estrangeiro, quando nome nÃ£o soar Brasileiro, ou a data de criaÃ§Ã£o do CPF for muito recente.
"""
    elif alert_type == 'pix_merchant_alert [BR]':
        prompt += f"""
A primeira frase da sua anÃ¡lise deve ser: "Cliente Merchant com possÃ­veis anomalias em PIX Cash In."
AtenÃ§Ã£o especial para TransaÃ§Ãµes PIX Cash-In e Cash-Out:

Para CADA transaÃ§Ã£o em Cash In e Cash Out, vocÃª DEVE:
1. Analisar os valores de Cash In para identificar quaisquer anomalias ou padrÃµes suspeitos.
2. Revisar os valores de Cash Out para detectar valores atÃ­picos ou incomuns.

Na sua anÃ¡lise, descreva:
- Quaisquer transaÃ§Ãµes de Cash In que apresentam valores anormais.
- Quaisquer transaÃ§Ãµes de Cash Out que apresentam valores atÃ­picos ou incomuns.
- PadrÃµes ou tendÃªncias observadas nas transaÃ§Ãµes PIX Cash-In e Cash-Out.
- RecomendaÃ§Ã£o sobre a necessidade de investigaÃ§Ã£o adicional com base nos achados.

Lembre-se: Esta verificaÃ§Ã£o deve ser feita para TODAS as transaÃ§Ãµes PIX relacionadas a este alerta.
Se nÃ£o houver anomalias ou valores atÃ­picos detectados, informe explicitamente na sua anÃ¡lise.
"""
    elif alert_type == 'international_cards_alert [BR]':
        prompt += f"""
A primeira frase da sua anÃ¡lise deve ser: "Cliente estÃ¡ transacionando com cartÃµes internacionais."
AtenÃ§Ã£o especial para TransaÃ§Ãµes com Issuer NÃ£o Brasileiro:

Para CADA transaÃ§Ã£o, vocÃª DEVE:
1. Verificar se o nome do emissor (issuer_name) da transaÃ§Ã£o nÃ£o Ã© de uma instituiÃ§Ã£o financeira brasileira.
2. Se o emissor nÃ£o for do Brasil, calcular:
   a) A soma total de valores transacionados com esse emissor especÃ­fico.
   b) A porcentagem que essa soma representa do TPV Total (conforme aplicÃ¡vel).

Na sua anÃ¡lise, descreva:
- A soma total de valores para cada emissor nÃ£o brasileiro correspondente.
- A porcentagem que esses valores representam do TPV total.
- Discuta quaisquer padrÃµes ou anomalias observados nessas transaÃ§Ãµes.

Lembre-se: Esta verificaÃ§Ã£o deve ser feita para TODAS as transaÃ§Ãµes relacionadas a este alerta.
Se nÃ£o houver correspondÃªncias com emissores nÃ£o brasileiros, informe explicitamente na sua anÃ¡lise.
"""
    elif alert_type == 'bank_slips_alert [BR]':
        prompt += f"""
A primeira frase da sua anÃ¡lise deve ser: "Cliente com possÃ­veis anomalias envolvendo boletos bancÃ¡rios."

AtenÃ§Ã£o especial para TransaÃ§Ãµes com MÃ©todo de Captura 'bank_slip':

Para CADA transaÃ§Ã£o, vocÃª DEVE:
1. Verificar se o mÃ©todo de captura (capture_method) da transaÃ§Ã£o Ã© 'bank_slip'.
2. Se for 'bank_slip', analisar:
   a) A soma total de valores transacionados com este mÃ©todo.
   b) A porcentagem que essa soma representa do valor do TPV TOTAL (conforme aplicÃ¡vel).

Na sua anÃ¡lise, descreva:
- A soma total de valores para transaÃ§Ãµes capturadas via 'bank_slip'.
- A porcentagem que esses valores representam do TPV total.
- Discuta quaisquer padrÃµes ou anomalias observados nessas transaÃ§Ãµes.

Lembre-se: Esta verificaÃ§Ã£o deve ser feita para TODAS as transaÃ§Ãµes relacionadas a este alerta.
Se nÃ£o houver transaÃ§Ãµes com mÃ©todo de captura 'bank_slip', informe explicitamente na sua anÃ¡lise.
"""
    elif alert_type == 'gafi_alert [US]':
        prompt += f"""
A primeira frase da sua anÃ¡lise deve ser: "Cliente estÃ¡ transacionando com paÃ­ses proibidos do GAFI."

AtenÃ§Ã£o especial para TransaÃ§Ãµes cujo issuer seja emitido em algum dos paÃ­ses abaixo:

'Bulgaria', 'Burkina Faso', 'Cameroon', 'Croatia', 'Haiti', 'Jamaica', 'Kenya', 'Mali', 'Mozambique',
'Myanmar', 'Namibia', 'Nigeria', 'Philippines', 'Senegal', 'South Africa', 'Tanzania', 'Vietnam', 'Congo, Dem. Rep.',
'Syrian Arab Republic', 'Turkey', 'Yemen, Rep.', 'Yemen Democratic', 'Iran, Islamic Rep.', 'Korea, Dem. Rep.' ,'Venezuela'

Para CADA transaÃ§Ã£o, vocÃª DEVE:
1. Verificar se o nome do emissor (issuer_name) da transaÃ§Ã£o nÃ£o Ã© de alguma instituiÃ§Ã£o financeira com oriens em algum dos paÃ­ses acima.
2. Se positivo, calcular:
   a) A soma total de valores transacionados com esse emissor especÃ­fico.
   b) A porcentagem que essa soma representa do TPV Total (conforme aplicÃ¡vel).
   c) Nomear o paÃ­s de origem.

Na sua anÃ¡lise, descreva:
- A soma total de valores para cada emissor com origens nos paÃ­ses acima, restritos pelo GAFI.
- A porcentagem que esses valores representam do TPV total.
- Discuta quaisquer padrÃµes ou anomalias observados nessas transaÃ§Ãµes.

Lembre-se: Esta verificaÃ§Ã£o deve ser feita para TODAS as transaÃ§Ãµes relacionadas a este alerta.
Se nÃ£o houver correspondÃªncias com emissores nÃ£o brasileiros, informe explicitamente na sua anÃ¡lise.
"""
    elif alert_type == 'pep_pix_alert [BR]' and pep_data is not None:
        pep_data_json = pep_data.to_json(orient='records', force_ascii=False, indent=2)
        prompt += f"""
A primeira frase da sua anÃ¡lise deve ser: "Cliente transacionando com Pessoas Politicamente Expostas (PEP)."

AtenÃ§Ã£o especial para as transaÃ§Ãµes identificadas abaixo:
{pep_data_json}

VocÃª DEVE:
1. Para cada PEP na lista, informar:
   - Nome completo do PEP (pep_name)
   - Documento do PEP (pep_document_number).
   - Cargo do PEP (job_description).
   - ÃrgÃ£o de trabalho (agencies).
   - Soma total dos valores transacionados com cada PEP (DEBIT + CREDIT).
   - A porcentagem que essa soma representa do total de Cash In e/ou Cash Out transacionado com outros indivÃ­duos.
2. Analisar se os valores e frequÃªncias das transaÃ§Ãµes com PEP sÃ£o atÃ­picos ou suspeitos.

Na sua anÃ¡lise, descreva:
- Detalhes das transaÃ§Ãµes com cada PEP identificado.
- Qualquer padrÃ£o ou anomalia observada nessas transaÃ§Ãµes.
- RecomendaÃ§Ãµes sobre a necessidade de investigaÃ§Ã£o adicional com base nos achados.

Lembre-se: Esta verificaÃ§Ã£o deve ser feita para TODAS as transaÃ§Ãµes de Cash In e Cash Out relacionadas a este alerta.
"""
    elif alert_type == 'AI Alert' and features:
        prompt += f"""
AtenÃ§Ã£o especial Ã s anomalias identificadas pelo modelo de AI:
{features}

Por favor, descreva os padrÃµes ou comportamentos anÃ´malos identificados com base nas caracterÃ­sticas acima.
VocÃª tambÃ©m deve analisar os demais dados disponÃ­veis, como transaÃ§Ãµes, contatos, dispositivos, issuing, produtos, para confirmar ou ajustar a suspeita de fraude.
"""
    elif alert_type == 'Issuing Transactions Alert':
        prompt += f"""
A primeira frase da sua anÃ¡lise deve ser: "Cliente estÃ¡ transacionando altos valores via Issuing."

AtenÃ§Ã£o especial para a tabela de Issuing e as seguintes informaÃ§Ãµes:
- Coluna total_amount
- mcc e mcc_description
- card_acceptor_country_code

Na sua anÃ¡lise, descreva:
- merchant_name com total_amount e percentage_of_total elevados.
- Se mcc e mcc_description fazem parte de negÃ³cios de alto risco.
- Se o paÃ­s em card_acceptor_country_code Ã© considerado um paÃ­s de alto risco.
"""

    return prompt

def get_gpt_analysis(prompt: str) -> str:
    """Gets the GPT analysis for the given prompt.

    Args:
        prompt (str): The prompt to send to the LLM.

    Returns:
        str: The GPT's analysis.
    """
    gpt_analysis = get_chatgpt_response(prompt)
    gpt_analysis = gpt_analysis.replace("R$", "R\\$")
    return gpt_analysis
